{{!this template will generate the main.c file}}


{{!the header tag includes all the header files used in the C code}}
{{#header}}
#include <{{.}}>
{{/header}}

{{!values which are defined using prerocessor directives are included in the directive tag}}
{{#directive}}{{#condition}}
#{{condition}} {{var}}
#define {{var}}       ({{value}})
#endif {{/condition}}
    {{^condition}}
#define {{var}}      ({{value}})
{{/condition}}{{/directive}}

{{!buffer tag is used for buffers which are definined globally}}
{{#buffer}}
static {{type}} {{.}}[{{size}}]{{#size2}}[{{size2}}]{{/size2}} ;
{{/buffer}}

{{#operations}}
{{#operation}} {{!operation corresponds to functions, operationId is the name of the function, additionalParams are the variables which are defined within the function}}
static {{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}void{{/returnType}} {{operationId}}({{#params}}{{dataType}} {{paramName}}{{^last}},{{/last}}{{/params}})
{
  {{summary}}
  
  {{#emcute_thread}}
  (void){{paramName}};
  
  emcute_run({{#directive}}{{EMCUTE_PORT}},{{EMCUTE_ID}}{{/directive}});
  return NULL;
  {{/emcute_thread}}
  
  {{#on_pub}}
  char *in = (char *)data;

    printf("### got publication for topic '%s' [%i] ###\n",
           {{#buffer}}{{topic}}->name, (int){{topic}}->id{{/buffer}});
    for (size_t i = 0; i < len; i++) {
        printf("%c", in[i]);
    }
    puts("");
    {{/on_pub}}
    
    {{#get_qos}}
    int qos= atoi({{paramName}});
    switch (qos) {
        case 1:     return EMCUTE_QOS_1;
        case 2:     return EMCUTE_QOS_2;
        default:    return EMCUTE_QOS_0;
    }
    {{/get_qos}}
    
    {{
   
  
  
   
  
}
{{/operation}}
{{/operations}}
  
  


{{!shellCommands is a list of commands and its associate description and operationId which are part of shell}}
static const shell_commands_t shell_commands[] = {
{{#shellCommands}}
{ "{{command}}","{{desc}}","{{operationId}}" },
{{/shellCommands}}
{NULL,NULL,NULL}
};

{{!only the name of buffers will change in the main() . I couldn.t figure it out now so I have kept it same}}
int main(void)
{
    puts("MQTT-SN IoT application\n");
    puts("Type 'help' to get started. Have a look at the README.md for more"
         "information.");
    {{#buffer}}{{#queue}}
    /* the main thread needs a msg queue to be able to run `ping6`*/
    msg_init_queue(queue, ARRAY_SIZE(queue));
    {{/queue}}
     {{#subscriptions}}
    /* initialize our subscription buffers */
    memset(subscriptions, 0, (NUMOFSUBS * sizeof(emcute_sub_t)));
    {{/subscriptions}}
    {{#stack}}
    /* start the emcute thread */
    thread_create(stack, sizeof(stack), EMCUTE_PRIO, 0,
                  emcute_thread, NULL, "emcute");
    {{/stack}}{{/buffer}}
    
    /* start shell */
    char line_buf[SHELL_DEFAULT_BUFSIZE];
    shell_run(shell_commands, line_buf, SHELL_DEFAULT_BUFSIZE);

    /* should be never reached */
    return 0;
}
